#!/usr/bin/env bash
set -euo pipefail

if ((BASH_VERSINFO[0] < 4)); then
  echo "Error: Bash 4.0+ is required (you are running ${BASH_VERSION})." >&2
  if [[ "$(uname)" == "Darwin" ]]; then
    echo "On macOS, try: brew install bash" >&2
  fi
  exit 1
fi

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
ROOT_DIR="$(cd "$SCRIPT_DIR/.." && pwd)"

# --- Load Core & Managers ---
source "$ROOT_DIR/lib/core.sh"
load_config "$ROOT_DIR/config/config.env"
load_defaults
source "$ROOT_DIR/lib/network_manager.sh"
source "$ROOT_DIR/lib/vm_manager.sh"
source "$ROOT_DIR/lib/template_manager.sh"

# --- Utils (UI Specific) ---
print_header() {
  cat << "EOF"
    _   _ ___ ____   ___  
   | \ | |_ _|  _ \ / _ \ 
   |  \| || || | | | | | |
   | |\  || || |_| | |_| |
   |_| \_|___|____/ \___/ 
                          
EOF
  echo "${BOLD}${BLUE}  Virtual Machine OPeration System${RESET}"
  echo "  ------------------------------------"
  echo ""
}

preflight() {
  if [[ "${VMOPS_SKIP_PREFLIGHT:-0}" == "1" ]]; then
    return 0
  fi
  printf "  ${BOLD}${BLUE}System Check${RESET} "
  local missing=0
  
  check_item() {
      local label=$1
      shift
      if "$@" >/dev/null 2>&1; then
          printf "${GREEN}â€¢${RESET}"
      else
          printf "${RED}â€¢${RESET}"
          missing=1
          return 1
      fi
  }

  check_item "Pool Path" [[ -d "$POOL_PATH" ]]
  check_item "Backup Dir" [[ -d "$BACKUP_DIR" ]]
  check_item "Libvirt Pool" virsh pool-info "$VMS_POOL"
  check_item "Host-only Net" virsh net-info "$NETWORK_HOSTONLY"
  check_item "NAT Net" virsh net-info "$NETWORK_NAT"
  
  if [[ "$missing" -eq 1 ]]; then
    echo " ${RED}${BOLD}FAILED${RESET}"
    echo "  ${ERR} Preflight check failed. Use ${YELLOW}nido selftest${RESET} for details." >&2
    exit 1
  fi
  echo " ${GREEN}READY${RESET}"
}

usage() {
  print_header
  cat <<EOF
${BOLD}Usage:${RESET} nido ${CYAN}<command>${RESET} [args]

${BOLD}Commands:${RESET}
  ${BOLD}spawn${RESET} <name> [tpl]      ${BLUE}Hatch${RESET} (create) and start a VM
  ${BOLD}create${RESET} <name> [tpl]     Just construct the nest (disk + domain)
  ${BOLD}start${RESET} <name>              Wake up a sleeping VM
  ${BOLD}stop${RESET} <name>               Put a VM to sleep
  ${BOLD}delete${RESET} <name>             Destroy the VM and its nest (disk)
  ${BOLD}ls${RESET} [regex]               List all birds in the neighborhood
  ${BOLD}info${RESET} <name>               Detailed bird-watching (IP/SSH/Specs)
  ${BOLD}prune${RESET}                    Clean up abandoned nests (orphan volumes)
  ${BOLD}template${RESET} <src> <tpl>    Preserve a bird species (backup VM)
  ${BOLD}setup${RESET}                    Wizard: Configure your nest interactively
  ${BOLD}config${RESET}                   View the current sacred scrolls
  ${BOLD}selftest${RESET}                 Run pre-flight diagnostics
  ${BOLD}version${RESET}                  Show technical lineage

${BOLD}Examples:${RESET}
  nido ${CYAN}spawn${RESET} parrot
  nido ${CYAN}ls${RESET}
  nido ${CYAN}info${RESET} parrot

EOF
}

cmd_version() {
  print_header
  echo "  ${BOLD}Version:${RESET} 2.2.0-core-refactor"
  echo "  ${BOLD}Codename:${RESET} Modular Macaw"
  echo "  ${BOLD}Engine:${RESET} Libvirt/QEMU-KVM"
  echo "  ${BOLD}Author:${RESET} JosÃ¨ Pavese"
  echo ""
}

# --- Command Wrappers (Connecting UI to Core) ---

cmd_create_ui() {
  local name="$1"
  local template="${2:-$TEMPLATE_DEFAULT}"
  local backup="$BACKUP_DIR/${template}.compact.qcow2"
  
  # Call Core API
  local out pid
  out=$(vm_create "$name" "$template" "$POOL_PATH" "$backup" \
                  "$VM_MEM_MB" "$VM_VCPUS" "$VM_OS_VARIANT" \
                  "$NETWORK_HOSTONLY" "$NETWORK_NAT" \
                  "$GRAPHICS" "$VM_NESTED")
  local ret=$?
  
  if [[ $ret -ne 0 ]]; then
      # vm_create prints error to stderr
      exit 1
  fi
  
  pid="$out" # vm_create prints PID on success
  spinner "$pid" "Preparing the nest (cloning disk)"
}

cmd_start_ui() {
  local name="$1"
  local template="${2:-$TEMPLATE_DEFAULT}"
  
  if ! virsh dominfo "$name" >/dev/null 2>&1; then
    cmd_create_ui "$name" "$template"
  fi
  
  vm_start "$name"
  
  # Wait for IP (UI specific logic)
  printf "  ${BOLD}${CYAN}..${RESET} Waiting for bird to chirp (IP)..."
  local start_ts=$(date +%s)
  local ip=""
  local spinstr='|/-\'
  local delay=0.2
  
  while true; do
    ip=$(network_get_ip "$name")
    if [[ -n "$ip" ]]; then
      printf "\r${OK} Bird is online! IP: ${YELLOW}$ip${RESET}    \n"
      
      local hn
      hn=$(network_get_hostname "$name")
      echo "VM: $name"
      echo "Hostname: $hn"
      echo "IP: $ip"
      echo "SSH: ssh $SSH_USER@$ip"
      return 0
    fi
    
    local temp=${spinstr#?}
    printf " [%c]" "$spinstr"
    local spinstr=$temp${spinstr%"$temp"}
    sleep $delay
    printf "\b\b\b\b"
    
    local end_ts=$(date +%s)
    if (( end_ts - start_ts >= WAIT_TIMEOUT )); then
      printf "\r${ERR} Timeout waiting for IP after ${WAIT_TIMEOUT}s.    \n"
      return 1
    fi
  done
}

cmd_stop_ui() {
  local name="$1"
  vm_stop "$name"
  echo "VM stopped: $name"
}

cmd_delete_ui() {
  local name="$1"
  vm_destroy "$name" "$VMS_POOL"
  echo "VM destroyed: $name"
}

cmd_ls_ui() {
  local regex="${1:-.}"
  
  mapfile -t vms < <(virsh list --all --name | awk 'NF' | grep -E "$regex" || true)
  if [[ ${#vms[@]} -eq 0 ]]; then
    echo "  ${INFO} No birds found in the nest (NAME_REGEX=$regex)."
    return 0
  fi
  
  printf "  ${BOLD}%-24s %-12s %-16s %s${RESET}\n" "VM NAME" "STATE" "IP ADDRESS" "CONNECTION"
  echo "  --------------------------------------------------------------------------------"
  
  for vm in "${vms[@]}"; do
    local ip state state_icon
    # We use network manager helper but don't want to spam virsh calls too much if slow
    ip=$(network_get_ip "$vm")
    state=$(virsh domstate "$vm" 2>/dev/null || echo "unknown")
    
    case "$state" in
        running)     state_icon="${GREEN}ðŸŸ¢ running${RESET}" ;;
        "shut off")  state_icon="${RED}ðŸ”´ stopped${RESET}" ;;
        paused)      state_icon="${YELLOW}ðŸŸ¡ paused${RESET}" ;;
        *)           state_icon="${CYAN}âšª $state${RESET}" ;;
    esac

    [[ -z "$ip" ]] && ip="(no-ip)"
    
    printf "  %-24s %-22s %-16s ${CYAN}%-18s${RESET}\n" \
      "$vm" "$state_icon" "$ip" "ssh $SSH_USER@$ip"
  done
  echo ""
}

cmd_info_ui() {
  local name="$1"
  if ! virsh dominfo "$name" >/dev/null 2>&1; then
    echo "  ${ERR} Domain not found: $name" >&2
    exit 1
  fi
  local hn ip state
  hn=$(network_get_hostname "$name")
  ip=$(network_get_ip "$name")
  state=$(virsh domstate "$name" 2>/dev/null || echo "unknown")
  
  [[ -z "$ip" ]] && ip="(no-ip)"

  echo "  ${BOLD}${BLUE}â”Œâ”€ VM DETECTED: $name${RESET}"
  echo "  ${BLUE}â”‚${RESET}  ${BOLD}State:${RESET}    $state"
  echo "  ${BLUE}â”‚${RESET}  ${BOLD}Hostname:${RESET} $hn"
  echo "  ${BLUE}â”‚${RESET}  ${BOLD}IP ADDR:${RESET}  ${YELLOW}$ip${RESET}"
  echo "  ${BLUE}â”‚${RESET}  ${BOLD}SSH CMD:${RESET}  ${CYAN}ssh $SSH_USER@$ip${RESET}"
  echo "  ${BLUE}â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${RESET}"
}

cmd_template_ui() {
  local src="$1"
  local tpl="$2"
  
  # Call Core API
  local pid
  pid=$(template_create "$src" "$tpl" "$BACKUP_DIR" "$VMS_POOL")
  local ret=$?
  
  if [[ $ret -ne 0 ]]; then
      # Error message already printed by template_create
      exit 1
  fi
  
  spinner "$pid" "Preserving species (compressing template)"
  
  echo "  ${OK} Compressed template created: ${YELLOW}$BACKUP_DIR/${tpl}.compact.qcow2${RESET}"
}

cmd_prune() {
  local vols
  mapfile -t vols < <(virsh vol-list "$VMS_POOL" | awk 'NR>2 && NF {print $1}')
  if [[ ${#vols[@]} -eq 0 ]]; then
    echo "No volumes in pool: $VMS_POOL"
    return 0
  fi
  mapfile -t domains < <(virsh list --all --name | awk 'NF')
  for vol in "${vols[@]}"; do
    local path in_use=0
    path=$(virsh vol-path --pool "$VMS_POOL" "$vol" 2>/dev/null || true)
    if [[ -z "$path" ]]; then
      continue
    fi
    for dom in "${domains[@]}"; do
      if virsh domblklist --details "$dom" 2>/dev/null | awk '{print $4}' | grep -qx "$path"; then
        in_use=1
        break
      fi
    done
    if [[ "$in_use" -eq 0 ]]; then
      virsh vol-delete --pool "$VMS_POOL" "$vol"
      echo "Deleted: $vol"
    else
      echo "In use: $vol"
    fi
  done
}

cmd_config() {
  local cfg="${VMOPS_CONFIG:-$ROOT_DIR/config/config.env}"
  print_header
  echo "  ${BOLD}Current Configuration:${RESET}"
  echo "  ${BLUE}Path:${RESET} $cfg"
  echo "  ------------------------------------"
  if [[ -f "$cfg" ]]; then
    # Pretty print content with syntax highlighting-ish
    while IFS= read -r line; do
       if [[ "$line" =~ ^# ]]; then
           echo "  ${CYAN}$line${RESET}"
       elif [[ "$line" =~ ^[A-Z_]+= ]]; then
           key="${line%%=*}"
           val="${line#*=}"
           echo "  ${BOLD}$key${RESET}=${YELLOW}$val${RESET}"
       else
           echo "  $line"
       fi
    done < "$cfg"
  else
     echo "  ${WARN} Configuration text not found. The scroll is blank!"
     echo "  Run ${BOLD}nido setup${RESET} to scribe it."
  fi
  echo ""
}

cmd_register() {
  local exe_path
  # Resolve symlinks or use absolute path
  exe_path=$(readlink -f "$0")
  
  print_header
  echo "  ${BOLD}IDE / MCP Configuration Helper${RESET}"
  echo "  Copy the JSON below into your Agent's config (e.g., mcp.json or claude_desktop_config.json):"
  echo ""
  
  cat <<EOF
  {
    "mcpServers": {
      "nido": {
        "command": "$exe_path",
        "args": [
          "mcp"
        ]
      }
    }
  }
EOF
  echo ""
  echo "  ${INFO} For Antigravity: Settings -> MCP Servers -> Manage -> View raw config"
  echo ""
}

# --- Main Dispatch ---

main() {
  require_cmds virsh awk grep ip qemu-img virt-install
  local cmd="${1:-}"
  shift || true

  case "$cmd" in
    spawn|start|stop|delete|destroy|ls|list|info|prune|template|create)
      preflight
      ;;
    mcp)
      # Skip CLI preflight for MCP (silent mode)
      ;;
  esac

  case "$cmd" in
    spawn)      cmd_start_ui "${@:?}";;
    create)     cmd_create_ui "${@:?}";;
    start)      cmd_start_ui "${@:?}";;
    stop)       cmd_stop_ui "${@:?}";;
    delete)     cmd_delete_ui "${@:?}";;
    destroy)    cmd_delete_ui "${@:?}";;
    ls|list)    cmd_ls_ui "${@}";;
    info)       cmd_info_ui "${@:?}";;
    prune)      cmd_prune;;
    template)   cmd_template_ui "${@:?}";;
    setup)
        source "$ROOT_DIR/lib/wizard.sh"
        run_wizard
        ;;
    mcp)
        # MCP Mode: Non-interactive, JSON-RPC
        export VMOPS_NON_INTERACTIVE=1
        source "$ROOT_DIR/lib/output_manager.sh"
        source "$ROOT_DIR/lib/mcp_server.sh"
        
        # --- IO SAFETY VALVE (Scoped) ---
        # 1. Capture the REAL stdout (for protocol) into FD 3
        exec 3>&1
        
        # 2. Run the main loop
        #    - We redirect all "normal" stdout to stderr (>&2) to capture logs/leaks
        #    - Inside the loop, `send_response` explicitly writes to FD 3
        run_mcp_server >&2
        ;;
    config)     cmd_config;;
    register)   cmd_register;;
    version)    cmd_version;;
    *)          usage;;
  esac
}

main "$@"
